Glosario

SO: sistema operativo
SE: sistema embebido
RT: tiempo real, la aplicación asegura cumplir los dead lines. Esa garantía la da el SO y el procesador.
ALU: unidad aritmético lógica

Preguntas orientadoras

1. 	Describa brevemente los diferentes perfiles de familias de microprocesadores/microcontroladores de ARM. Explique alguna de sus diferencias características. 

Los perfiles son líneas de productos, orientadas a determinados mercados o soluciones. Tienen que ver con el rendimiento esperado, y se deben elegir según 
la aplicación requerida. Los tres perfiles de ARM son los cortex A, cortex R y cortex M.

Cortex A: línea orientada a aplicaciones (corren en un SO de propósito general, como Android). Procesadores de alto rendimiento orientados a la implementación 
de SO en SE de alta performance (optimizados para correr aplicaciones de usuario en un SO multitarea). Pueden procesar muchas cosas al mismo tiempo, pero 
es un procesamiento no determinista (pueden existir demoras). No es adecuado para aplicaciones en RT.

Cortex R: línea orientada a tiempo real. Procesadores orientados a sistemas de RT donde la necesidad principal es implementar soluciones de baja latencia y alta 
capacidad de procesamiento. Ejemplos: sistemas del automóvil (seguridad, frenado, etc.), sistemas médicos, industriales, etc.
El cortex R es como un cortex A (alta capacidad de procesamiento) pero sin la capacidad de hacer que las aplicaciones corran rápido. Es un procesador potente 
pero orientado a correr aplicaciones de RT (baja latencia y alta capacidad de procesamiento). No tienen memoria caché.

Cortex M: línea orientada a microcontroladores. Procesadores orientados a dispositivos de consumo masivo y sistemas embebidos compactos (diseñados para 
alta densidad de código y programación en C). Comparado con un cortex M, un cortex A tiene mucha más capacidad de procesamiento, pero tiene mucho mayor 
consumo y costo. Los cortex M ya vienen con memoria, flash, periféricos internos. Los cortex A no.

Cortex M

1. 	Describa brevemente las diferencias entre las familias de procesadores Cortex M0, M3 y M4

Cortex M0: posee arquitectura ARMv6-M y arquitectura de memoria Von-Neumann (bus único). No posee MPU. Admite sólo instrucciones de 32 bits y no soporta 
todo el set de instrucciones Thumb. Presenta una implementación mínima de bajo costo para aplicaciones sencillas que requieren bajo consumo.

Cortex M3: posee arquitectura ARMv7-M y arquitectura Harvard (más rápida). Admite instrucciones hasta 64 bits y soporta Thumb. Presentan mayor performance 
y capacidades de protección a memoria. El set de instrucciones más extenso permite operaciones más avanzadas y eficientes, tales como la división por hardware.

Cortex M4: posee arquitectura ARMv7E-M y arquitectura Harvard. Admite instrucciones hasta 64 bits y soporta Thumb. Tiene posibilidad de agregar memoria 
caché al CPU. Respecto a M3, el set de instrucciones es más extenso y los co-procesadores son más potentes, permitiendo procesamiento digital de señales (DSP) 
y operaciones de punto flotante (FPU).

2.	¿Por qué se dice que el set de instrucciones Thumb permite mayor densidad de código? Explique. 

Se dice que el set de instrucciones Thumb permite mayor densidad de código porque permite ejecutar las mismas tareas empleando un tamaño de programa menor. 
Esto reduce tanto el costo como el consumo de energía.

3.	¿Qué entiende por arquitectura load-store? ¿Qué tipo de instrucciones no posee este tipo de arquitectura?

En una arquitectura load-store, el set de instrucciones se divide en dos tipos: de acceso a memoria (load y store entre memoria y registros) y de operaciones de la 
ALU (sólo entre registros). Un ejemplo de arquitectura con este modelo es el x86. En la primera, se cargan datos desde la memoria a los registros internos del 
procesador (lectura) y también desde estos registros hacia la memoria (escritura). En la segunda, se tiene como operandos sólo registros del procesador, por lo 
que, para ejecutar operaciones entre posiciones de memoria primero se deben cargar éstas en los registros del procesador.
En resumen, ninguna instrucción opera directamente sobre memoria, por lo que para acceder u operar sobre un valor en memoria, primero se lo debe cargar en 
un registro, y luego se lo debe guardar en un registro para pasarlo nuevamente a memoria.

4.	¿Cómo es el mapa de memoria de la familia? 

El mapa de memoria de los Cortex M es plano de 4GB. Presenta secciones definidas para el programa, la memoria RAM, los periféricos, etc. Cada sección comienza 
en un determinado lugar de la memoria representado con un offset.

7.	¿Qué se entiende por modelo de registros ortogonal? Dé un ejemplo.

En un modelo de registros ortogonal, todos los registros (excepto stack pointer, link register y program counter) pueden ser utilizados de forma indistinta por las 
instrucciones. Las instrucciones no operan sobre registros específicos, si no que existe un grupo de registros de propósito general en el cual todas las instrucciones 
pueden operar. En los Cortex M3 y M4, existen 13 registros de propósito general (r0 a r12) en donde pueden operar las instrucciones de AND, ADD, MOV, etc. sobre 
cualquier registro. Por ejemplo, la suma entre los registros r9 y r11: ADD r9, r11.

10.	Describa las funciones principales de la pila. ¿Cómo resuelve la arquitectura el llamado a funciones y su retorno?

• Push: copia el valor de un registro en la posición inferior a la apuntada por la pila (se decrementa). Luego el puntero queda en esa posición.
• Pop: copia el valor de la posición apuntada por la pila en un registro. Luego el puntero se vuelve a la posición superior (se incrementa) disponible en la pila.
Nota: la pila crece hacia abajo.

El stack pointer tiene otras funciones como swap, peek, duplicate y rotate. Por ejemplo, en swap se intercambian las posiciones de los últimos dos valores de la pila, 
en peek se recupera el próximo valor del stack en un registro (similar a pop, pero sin incrementar el puntero a la siguiente posición disponible), etc. 

12.	¿Qué entiende por “core peripherals”? ¿Qué diferencia existe entre estos y el resto de los periféricos? 

Son los periféricos diseñados e implementados por el fabricante del núcleo (ARM). A diferencia del resto de los periféricos, estos se encuentran físicamente en el 
núcleo del procesador, por lo que son de baja latencia (ejemplo SysTick, MPU, NVIC). Cualquier fabricante de microcontroladores con núcleo ARM (ejemplo ST) 
tendrá dichos periféricos embebidos en el core, además de los periféricos externos al mismo que decida incluir en su diseño.

13.	¿Cómo se implementan las prioridades de las interrupciones? Dé un ejemplo.

Las interrupciones se implementan sobre un arreglo, con mayor prioridad a menor índice. La prioridad de las interrupciones se puede elegir, excepto para reset, 
NMI y HardFault, cuyas posiciones en el arreglo son fijas. Por ejemplo, la interrupción con mayor prioridad será la ubicada en el primer lugar del arreglo (índice 0).

14.	¿Qué es el CMSIS? ¿Qué función cumple? ¿Quién lo provee? ¿Qué ventajas aporta? 

El CMSIS es una interfaz de software común a todos los microprocesadores Cortex, implementada en C. Le permite al programador el acceso a los core peripherals 
de manera más amigable, sin tener que interactuar de manera directa con los registros del microcontrolador. Se ubica entre la capa de middleware y el hardware. 
Permite poner a andar los periféricos internos en poco tiempo y con el respaldo del fabricante del microcontrolador, quien lo provee, con documentación 
respaldatoria del mismo y de toda una comunidad de usuarios.

17.	¿Qué es el systick? ¿Por qué puede afirmarse que su implementación favorece la portabilidad de los sistemas operativos embebidos? 

El systick es un timer en el procesador, que genera una interrupción constante con una periodicidad de 1ms. Permite medir tiempos, así como también asignar tareas 
dentro de su rutina de interrupción asociada. En base a este tiempo, se pueden gestionar cambios entre una y otra tarea en ejecución. 
Su implementación favorece la portabilidad de los SO embebidos ya que todos los microcontroladores, de cualquier fabricante, con licencia de núcleo ARM, tienen 
este mismo timer en el procesador, por lo que se fomenta su buen uso en lugar de un timer externo.

18.	¿Qué funciones cumple la unidad de protección de memoria (MPU)? 

El MPU permite definir y controlar el acceso a determinadas regiones de memoria, asignadas a distintos programas. Para esto diferencia regiones privilegiadas y no 
privilegiadas. De este modo un programa no puede afectar el funcionamiento del resto del sistema, ya sea por un error de programación o de manera mal intencionada.

ISA

1. ¿Qué son los sufijos y para qué se los utiliza? Dé un ejemplo 

2. ¿Para qué se utiliza el sufijo ‘s’? Dé un ejemplo

El sufijo 's' se utiliza para actualizar los flags de estado. Por ejemplo, la instrucción “adds ro, r1” lo que hace es ro = ro+r1 y actualizar el flag de estado.

3. ¿Qué utilidad tiene la implementación de instrucciones de aritmética saturada? Dé un ejemplo con operaciones con datos de 8 bits.

4. Describa brevemente la interfaz entre assembler y C ¿Cómo se reciben los argumentos de funciones? ¿Cómo se devuelve el resultado? ¿Qué registros deben guardarse en la pila antes de ser modificados? 




